class Solution:
    
    def isMatch(self, text, pattern):

        memo = {}
        
        def calculate(i, j):
            
            if (i, j) in memo: return memo[(i,j)]
            
            # pattern ends, text must end
            if j == len(pattern):
                ans = (i == len(text))
            
            else:
                
                curMatch = i < len(text) and (pattern[j] == text[i] or pattern[j] == '.')
                
                if j + 1 < len(pattern) and pattern[j+1] == '*':
                    
                    # curMatch matches so check next text. j stays because text[i+1] could be duplicated
                    ans = curMatch and calculate(i+1, j)
                    
                    # curMatch does not match, use this * to erase j-th pattern
                    ans = ans or calculate(i, j+2)
                
                else:
                    
                    ans = curMatch and calculate(i+1, j+1)
                    
            memo[(i,j)] = ans
            
            return ans
        
        return calculate(0,0)
            